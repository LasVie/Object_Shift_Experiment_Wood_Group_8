<!DOCTYPE html>
<html>

<head>
  <title>Visual Perception Experiment</title>

  <!-- Include jsPsych core and plugins -->
  <script src="jspsych/dist/jspsych.js"></script>
  <script src="jspsych/dist/plugin-html-button-response.js"></script>
  <script src="jspsych/dist/plugin-call-function.js"></script>

  <!-- Default jsPsych styling -->
  <link href="jspsych/dist/jspsych.css" rel="stylesheet" type="text/css" />

  <style>
    p {
      text-align: justify;
    }

    .university-logo {
      position: absolute;
      top: 10px;
      left: 10px;
      height: 60px;
    }

    .welcome-container {
      margin-top: 20px;
      margin-left: 100px;
      margin-right: 20px;
      text-align: left;
    }

    .demo-image {
      max-width: 45vw;
      max-height: calc(100vh - 150px);
      width: auto;
      height: auto;
    }

    .jspsych-btn {
      font-weight: bold;
      font-size: 20px;
      background: #4CAF50;
      color: #fff;
      border: none;
      border-radius: 4px;
      padding: 10px 20px;
      cursor: pointer;
    }

    .jspsych-btn:hover {
      background: #45a049;
    }

    #yes-button-container {
      position: fixed;
      bottom: 0;
      right: 40px;
      z-index: 1000;
    }

    #fullscreen-overlay {
      position: fixed;
      inset: 0;
      background: rgba(128, 128, 128, .7);
      z-index: 10000;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    #fullscreen-overlay .prompt-box {
      background: #fff;
      padding: 20px;
      border-radius: 8px;
      box-shadow: 0 0 10px rgba(0, 0, 0, .5);
      max-width: 90%;
      text-align: center;
    }

    #fullscreen-overlay button {
      font-size: 16px;
      margin: 10px;
      padding: 8px 16px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
    }

    #fullscreen-overlay button:hover {
      opacity: 0.9;
    }

    .loading-container {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      font-family: Arial;
      margin-top: 50px;
    }

    .loading-container p {
      font-size: 24px;
      margin-bottom: 10px;
    }

    .progress-bar-container {
      width: 300px;
      height: 20px;
      background: #eee;
      border-radius: 10px;
      overflow: hidden;
      box-shadow: inset 0 0 5px rgba(0, 0, 0, .2);
    }

    .progress-bar {
      height: 100%;
      width: 0%;
      background: #007bff;
      border-radius: 10px;
      transition: width .2s;
    }

    #progress-circle {
      position: fixed;
      bottom: 10px;
      left: 10px;
      width: 30px;
      height: 30px;
      border-radius: 50%;
      background: conic-gradient(#4CAF50 0deg, #4CAF50 360deg, #ccc 360deg, #ccc 360deg);
      z-index: 1000;
      display: none;
    }

    .jspsych-html-button-response-stimulus,
    #jspsych-html-button-response-btngroup {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
    }

    /* ───────────── HIDE VIDEO SEEK / TIME BAR ───────────── */
    /* Chromium / Edge / Safari */
    video.no-progress::-webkit-media-controls-timeline,
    video.no-progress::-webkit-media-controls-current-time-display,
    video.no-progress::-webkit-media-controls-time-remaining-display {
      display: none !important;
    }

    /* Firefox – hide the timeline and draggable knob */
    video.no-progress::-moz-range-track,
    video.no-progress::-moz-range-thumb {
      visibility: hidden !important;
    }

    #zoom-overlay {
      position: fixed;
      inset: 0;
      background: rgba(128, 128, 128, .7);
      z-index: 10000;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    #zoom-overlay .prompt-box {
      background: #fff;
      padding: 24px 32px;
      border-radius: 8px;
      box-shadow: 0 0 12px rgba(0, 0, 0, .4);
      max-width: 90%;
      text-align: center;
    }

    #zoom-overlay button {
      margin: 12px 10px 0;
      padding: 8px 18px;
      font-size: 16px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
    }

    #zoom-overlay button:hover {
      opacity: .9;
    }

    #demo-content.fullbleed,
    #exp-content.fullbleed {
      width: 100vw !important;
      margin-left: calc(50% - 50vw) !important;
      margin-right: calc(50% - 50vw) !important;
    }

    #demo-content.fullbleed>div,
    #exp-content.fullbleed>div {
      margin: 0 !important;
    }

    .caption {
      display: block;
      text-align: center;
      font-size: 14px;
      margin-top: -8px;
      position: relative;
      top: -5px;
    }
  </style>

  <style>
    #exp-content>div {
      margin: 0 !important;
    }

    #exp-content .demo-image {
      max-width: none;
    }
  </style>

  <!-- ---------- Worker-ID helpers ---------- -->
  <script>
    function generateRandomDigits(n) { let s = ''; for (let i = 0; i < n; i++) s += Math.floor(Math.random() * 10); return s; }
    function buildParticipantID(id) { const d = new Date().getDate(); return `${id}@${d * 25 + generateRandomDigits(4)}`; }
  </script>
</head>

<body>
  <div id="yes-button-container"></div>
  <div id="progress-circle"></div>

  <script>
    /********* GLOBALS & FULLSCREEN-EXIT HANDLER *********/
    var yesClickEvents = []; function clearYesClickEvents() { yesClickEvents = []; }
    var demoPaused = false;
    window.demoPixelShift = null;
    var demoVideoStartTime = 0, demoVideoWatchTime = 0;

    function pauseAwareTimeout(cb, d) { setTimeout(function f() { demoPaused ? setTimeout(f, 100) : cb(); }, d); }
    function parseShiftFromFilename(u) { const m = u.match(/_(L|R|U|D)(\d+)px/); return m ? { direction: m[1], shift: +m[2] } : { direction: null, shift: 0 }; }

    var jsPsych = initJsPsych({ override_safe_mode: true, experiment_width: 1000 });

    document.addEventListener('fullscreenchange', function () {
      if (!document.fullscreenElement) {
        demoPaused = true;
        const ov = document.createElement('div'); ov.id = 'fullscreen-overlay';
        const box = document.createElement('div'); box.className = 'prompt-box';
        box.innerHTML = 'You have exited full screen mode.<br><br>\
                       Press <strong>Resume</strong> to re-enter full screen, or \
                       <strong>Quit</strong> to return to the main screen (all progress lost!).';
        const q = document.createElement('button'); q.textContent = 'Quit';
        q.style.background = '#d9534f'; q.style.color = '#fff';
        q.onclick = () => { document.body.removeChild(ov); window.location.reload(); };
        const r = document.createElement('button'); r.textContent = 'Resume';
        r.style.background = '#5cb85c'; r.style.color = '#fff';
        r.onclick = () => {
          document.body.removeChild(ov);
          document.documentElement.requestFullscreen().then(() => { demoPaused = false; jsPsych.resumeExperiment?.(); });
        };
        box.appendChild(q); box.appendChild(r); ov.appendChild(box); document.body.appendChild(ov); jsPsych.pauseExperiment?.();
      }
    });
  </script>

  <!-- ---------- Stimulus lists & filename-cache ---------- -->
  <script>
    const SCALES = [0.9, 0.75, 0.6];
    let scaleIndex = 0;
    const imageCache = {};
    window.stimSizesByScale = {};
    window.baseInterImageGapPx = null;

    var objectNames = [
      //"Book Shelves", "Chess", "Wheel","Food Platter", "Fruits", "Humming Bird","Plant","Swing", "Vase", 
      "Wood",//"BronzeCat","Remote",
    ];
    var groups = {
      // "Group1": ["Center_100%_Plain"],
      // "Group2": ["Center_100%_LowContrast"],
      // "Group3": ["Left_100%_Plain"],
      // "Group4": ["Right_100%_Plain"],
      // "Group5": ["Up_100%_Plain"],
      // "Group6": ["Down_100%_Plain"],
      // "Group7": ["Center_125%_Plain"],
      "Group8": ["Center_75%_Plain"],
      // "Group9": ["Center_100%_PatternHoriz"],
      // "Group10": ["Center_100%_PatternVert"],
      // "Group11": ["Center_100%_Messy"],
    };
    function getRandomElement(a) { return a[Math.floor(Math.random() * a.length)]; }

    window._allFilenamesPromise = null; window._filenameListCache = {};
    function fetchImageFilenames(key) {
      if (!window._allFilenamesPromise) {
        window._allFilenamesPromise = fetch("https://lasvientuexperimentdata.s3.ap-southeast-1.amazonaws.com/Rendered+Images/filenames.json", { cache: "force-cache" })
          .then(r => { if (!r.ok) throw new Error(r.status); return r.json(); });
      }
      if (window._filenameListCache[key]) return Promise.resolve(window._filenameListCache[key]);
      return window._allFilenamesPromise.then(d => {
        const match = d.filter(f => f.name.includes(key)).sort((a, b) => a.name.localeCompare(b.name)).map(f => f.name);
        window._filenameListCache[key] = match; return match;
      });
    }
  </script>

  <!-- ====================================================================
     HELPER Fuctions
==================================================================== -->
  <script>
    /* returns a Promise that resolves with an Image(), using the cache */
    function loadImage(url) {
      if (imageCache[url]) return Promise.resolve(imageCache[url]);

      return new Promise((resolve, reject) => {
        const img = new Image();
        img.onload = () => { imageCache[url] = img; resolve(img); };
        img.onerror = () => reject(url);
        img.src = url;
      });
    }

    function edgeLayout(leftId, rightId, containerId, scale, opts = {}) {
      const { mode = 'edges', gapPx = null } = opts;

      const wrap = document.getElementById(containerId);
      const leftEl = document.getElementById(leftId);
      const rightEl = document.getElementById(rightId);
      if (!wrap || !leftEl || !rightEl) return;

      // Base container
      wrap.style.display = 'flex';
      wrap.style.alignItems = 'center';
      wrap.style.width = '100%';
      wrap.style.margin = '0';
      wrap.style.padding = '0';
      wrap.style.gap = '0px';
      wrap.style.justifyContent = (mode === 'edges') ? 'space-between' : 'center';

      // Normalize the two wrappers so flex centering works perfectly
      [leftEl.parentElement, rightEl.parentElement].forEach(w => {
        if (!w) return;
        w.style.margin = '0';
        w.style.textAlign = 'center';
        w.style.flex = '0 0 auto';
        w.style.minWidth = '0';
      });

      // Scale images
      leftEl.style.transform = `scale(${scale})`;
      rightEl.style.transform = `scale(${scale})`;

      // Transform origin:
      //  - edges mode: hug the outer edges
      //  - gap   mode: scale around the center to keep the canvases visually aligned
      leftEl.style.transformOrigin = (mode === 'edges') ? 'left center' : 'center center';
      rightEl.style.transformOrigin = (mode === 'edges') ? 'right center' : 'center center';

      // Force a layout pass so measurements include transforms
      leftEl.getBoundingClientRect();

      // For 0.75 / 0.6 runs: use the exact gap measured at 0.9, clamped to what fits
      if (mode === 'gap' && typeof gapPx === 'number') {
        const contW = wrap.clientWidth;
        const lW = Math.round(leftEl.getBoundingClientRect().width);
        const rW = Math.round(rightEl.getBoundingClientRect().width);
        const maxGap = Math.max(0, contW - lW - rW);
        const useGap = Math.min(Math.max(0, Math.round(gapPx)), maxGap);

        wrap.style.gap = useGap + 'px';
      }
    }

    function measureBaseGapWhenReady() {
      if (typeof window.baseInterImageGapPx === 'number') return;

      const left = document.getElementById('exp-ref-image');
      const right = document.getElementById('exp-shift-image');
      if (!left || !right) return;

      let pending = 0, need = [];
      if (!left.complete) { pending++; need.push(left); }
      if (!right.complete) { pending++; need.push(right); }

      const finish = () => {
        requestAnimationFrame(() => {
          const l = left.getBoundingClientRect();
          const r = right.getBoundingClientRect();
          const gap = r.left - l.right;
          if (gap >= 0) window.baseInterImageGapPx = gap;
        });
      };

      if (pending === 0) finish();
      else {
        const onload = () => { if (--pending === 0) finish(); };
        need.forEach(img => img.addEventListener('load', onload, { once: true }));
      }
    }

    function whenBaseGapKnown(cb) {
      if (typeof window.baseInterImageGapPx === 'number') return cb(window.baseInterImageGapPx);
      let tries = 0;
      (function poll() {
        if (typeof window.baseInterImageGapPx === 'number') cb(window.baseInterImageGapPx);
        else if (++tries < 20) requestAnimationFrame(poll);
      })();
    }

    function nudgeSpacerToTarget(containerId, targetGap) {
      requestAnimationFrame(() => {
        const left = document.getElementById('exp-ref-image');
        const right = document.getElementById('exp-shift-image');
        const spacer = document.getElementById(containerId + '-spacer');
        if (!left || !right || !spacer) return;

        const cur = right.getBoundingClientRect().left - left.getBoundingClientRect().right;
        const delta = targetGap - cur; // positive -> widen spacer
        if (Math.abs(delta) >= 1) {
          const curW = parseFloat(spacer.style.width) || 0;
          spacer.style.width = (curW + delta) + 'px';
        }
      });
    }

    /* For 0.75 only: after laying out with a requested gap,
       measure the *visible* gap (post-transform) and nudge the
       container's gap so it matches the 0.9 target exactly. */
    function nudgeGapToTarget(containerId, targetGap) {
      requestAnimationFrame(() => {
        const wrap = document.getElementById(containerId);
        const left = document.getElementById('exp-ref-image');
        const right = document.getElementById('exp-shift-image');
        if (!wrap || !left || !right) return;

        const cur = right.getBoundingClientRect().left - left.getBoundingClientRect().right;
        const delta = Math.round(targetGap - cur);       // +ve => need bigger gap
        if (delta !== 0) {
          const cs = getComputedStyle(wrap);
          const currentGap =
            parseFloat(cs.columnGap || cs.gap || wrap.style.gap || 0) || 0;
          wrap.style.gap = Math.max(0, currentGap + delta) + 'px';
        }
      });
    }
  </script>

  <!-- ================== 1) Welcome Page ================== -->
  <script>
    var welcomePage = {
      type: jsPsychHtmlButtonResponse,
      stimulus: `
        <img src="logo/NTU Logo.png" alt="NTU Logo" class="university-logo" style="height:230px; width:auto;">
        <div class="welcome-container">
          <h1>Visual Perception Experiment</h1>
          <p>
            This study aims to evaluate the sensitivity of the human visual system
            to subtle shifts in the position of a salient object. You will see images
            where a key object may be displaced in various directions. Your task is
            to detect these shifts.
          </p>
          <p style="color:red; font-weight:bold;">
            Please do not refresh the page during the experiment; refreshing will cause all progress to be lost.
            <br>
            Only refresh if images fail to load.
            <br>
            <br>
            Please set the browser zoom level to 100%, failing to do so will result in HIT task rejection. 
          </p>

          <!-- NEW: Worker ID textbox -->
          <p>
            <label for="worker-id-input"><b>Enter your MTurk Worker&nbsp;ID (Incorrect ID will not recieve payout):</b></label>
            <input type="text" id="worker-id-input" name="worker-id-input"
                   style="margin-left:10px; width:190px;" required>
          </p>

          <p>
            <input type="checkbox" id="device-confirm" name="device-confirm">
            <label for="device-confirm">I confirm that I am using a desktop PC or laptop.</label>
          </p>
        </div>
      `,
      choices: ['Continue'],

      on_load: function () {
        const btn = document.querySelector(".jspsych-btn");
        const idInput = document.getElementById("worker-id-input");
        const deviceC = document.getElementById("device-confirm");

        function toggleButton() {
          btn.disabled = !(deviceC.checked && idInput.value.trim().length);
        }
        btn.disabled = true;
        idInput.addEventListener("input", toggleButton);
        deviceC.addEventListener("change", toggleButton);

        btn.addEventListener("click", () => {
          const workerId = idInput.value.trim();
          window.participantID = buildParticipantID(workerId);
        });
      },

      on_finish: function () {
        if (!document.fullscreenElement) {
          document.documentElement.requestFullscreen().catch(function (err) {
            console.error("Error attempting to enable full screen:", err);
          });
        }
      }
    };
  </script>

  <script>
    /* ------------------------------------------------------------------
     * Disqualify notice + ONE-SHOT upload
     * ----------------------------------------------------------------*/
    function showDisqualifyPage(reason = "verification_fail") {

      /* ===== 1)  SEND minimal payload ===== */
      /* make sure the constant exists somewhere global */
      const AWS_ENDPOINT = "https://i7nc0ict3h.execute-api.ap-southeast-1.amazonaws.com/storedata";

      /* build payload as Lambda expects */
      fetch(AWS_ENDPOINT, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          participantID: window.participantID || Date.now().toString(),
          demoVideoWatchTime: 0  // REQUIRED: always 0 for fails
        })
      }).catch(err => console.error("DQ upload error:", err));

      /* ===== 2)  Replace the DOM with ‘fail’ page ===== */
      document.body.innerHTML = `
    <style>
      body{margin:0;background:#f7f7f7;font-family:Arial,Helvetica,sans-serif}
      #dq-wrap{max-width:680px;margin:14vh auto;background:#fff;border-radius:12px;
               box-shadow:0 8px 28px rgba(0,0,0,.12);padding:50px 60px 60px;text-align:center}
      #dq-wrap h2{margin-top:0;font-size:28px;color:#d9534f}
      #dq-wrap p{font-size:18px;line-height:1.5;margin:22px 0 36px;color:#333}
      #dq-close{padding:12px 46px;font-size:20px;border:none;border-radius:6px;
                background:#d9534f;color:#fff;cursor:pointer}
      #dq-close:hover{opacity:.9}
    </style>

    <div id="dq-wrap">
      <h2>Device requirements not met</h2>
      <p>
        Your monitor size / resolution is outside the limits for this experiment.<br>
        The HIT associated with this session will unfortunately be <strong>rejected</strong>.<br>
        You may close this page now.
      </p>
      <button id="dq-close">Close</button>
    </div>`;

      /* close the tab / window when the user clicks Close */
      document.getElementById("dq-close").onclick = () => {
        window.open('', '_self');
        window.close();
      };
    }
  </script>

  <!-- ================= 2) DISPLAY-VERIFICATION PAGE  ================= -->
  <script>
    /* ──────────────────────────────────────────────────────────────────────────────
     *  GLOBAL HELPERS
     * ──────────────────────────────────────────────────────────────────────────── */
    let recheckAttempts = 0;                     // # times “Re-check” pressed

    const badge = ok =>
      ok
        ? '<span style="color:#28a745;font-weight:bold;">PASS</span>'
        : '<span style="color:#dc3545;font-weight:bold;">FAIL</span>';

    let _zb = null;                              // zoom-blocker handle
    function installZoomBlocker() {
      _zb = e => {
        if ((e.ctrlKey || e.metaKey) &&
          (['+', '=', '-', '_', '0'].includes(e.key) || e.type === 'wheel')) {
          e.preventDefault();
          return false;
        }
      };
      window.addEventListener('keydown', _zb, { passive: false });
      window.addEventListener('wheel', _zb, { passive: false });
    }
    function removeZoomBlocker() {
      if (_zb) {
        window.removeEventListener('keydown', _zb, { passive: false });
        window.removeEventListener('wheel', _zb, { passive: false });
        _zb = null;
      }
    }

    /* ──────────────────────────────────────────────────────────────────────────────
     *  jsPsych TRIAL  ▸  verificationPage
     * ──────────────────────────────────────────────────────────────────────────── */
    const verificationPage = {
      type: jsPsychHtmlButtonResponse,

      /* three buttons in this order */
      choices: ['Re-check', 'Quit', 'Continue'],

      /* jsPsych 7 calls this as a function; older versions accept it too           */
      /* i  = index (0,1,2)   label = '%choice%' placeholder                         */
      button_html: function (choice, index) {
        const style = (index === 1)
          ? 'style="background:#d9534f;color:#fff;"'
          : '';
        return `<button class="jspsych-btn" ${style}>${choice}</button>`;
      },

      /* ------------------------------------------------------------------------ */
      stimulus: () => {
        // ───────── inside verificationPage.stimulus (and again in on_load) ─────────
        const dpr = window.devicePixelRatio || 1,
          swCSS = screen.width,
          shCSS = screen.height,
          vw = innerWidth,
          vh = innerHeight,
          swPhy = Math.round(swCSS * dpr),
          shPhy = Math.round(shCSS * dpr);

        // 👇 NEW tolerance band for a 1920 × 1080 panel
        const ok1080 = (swPhy >= 1880 && swPhy <= 1960) &&   // allow ±40 px
          (shPhy >= 1040 && shPhy <= 1120);

        const okDPR = (dpr >= 1.20 && dpr <= 1.30);
        const winOK = Math.abs(((swCSS * dpr) / innerWidth) - dpr) < 0.02;
        const passAll = ok1080 && okDPR && winOK;
        const style = `
        <style>
          /* Prevent scrolling */
          html, body {
            height: 100%;
            overflow: hidden;
          }

          /* Keep content visible and non-overlapping */
          .jspsych-content {
            padding-bottom: 120px !important; /* Reserve space for fixed button group */
          }

          /* Allow full height usage without forcing scrollbars */
          .jspsych-content-wrapper {
            height: 100vh;
            min-height: 0;
          }

          /* PASS/FAIL message styling */
          #card-msg {
            min-height: 28px;       /* Prevent layout shift when FAIL text appears */
            margin-top: 8px;
            position: relative;
            top: -8px;              /* Move PASS/FAIL line slightly upward */
            font-size: 18px;
            font-weight: 700;
            text-align: center;     /* Center horizontally */
          }

          /* Slider area (optional spacing improvement) */
          #card-slider {
            margin-bottom: 20px;    /* Keeps space above fixed button area */
          }

          /* Fixed, centered button group at the bottom */
          #jspsych-html-button-response-btngroup {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex !important;
            justify-content: center !important;
            gap: 24px;
            margin: 0;
            z-index: 10;
            width: auto;
          }

          /* General button styling */
          .jspsych-btn {
            font-size: 18px;
            padding: 10px 32px;
          }

          /* Optional fine-tune: nudge Continue button a little higher */
          .jspsych-btn:nth-child(3) {
            transform: translateY(-4px);
          }
        </style>
          `;
        let html = style + `
          <h2 style="text-align:center;margin-top:10px;">Display Verification</h2>

          <table style="margin:0 auto;font-size:18px;line-height:1.4;">
            <tr><td><b>Device resolution&nbsp;(physical)</b></td>
                <td>${swPhy} × ${shPhy}&nbsp;px</td></tr>
            <tr><td><b>Browser viewport&nbsp;(CSS)</b></td>
                <td>${vw} × ${vh}&nbsp;px</td></tr>
            <tr><td><b>OS scaling factor</b></td>
                <td>${dpr.toFixed(2)}&nbsp;(~${Math.round(dpr * 100)}%)</td></tr>
          </table>

          <p style="text-align:center;font-size:22px;margin:20px 0;">
            Resolution&nbsp;status&nbsp;:&nbsp;${badge(passAll)}
          </p>

          <p style="max-width:800px;margin:0 auto 40px;font-size:17px;text-align:left;">
            We require a 1920 × 1080 monitor (≈ 15.6″) at
            <b>125 % OS scaling</b> and <b>100 % browser zoom</b>.
          </p>`;

        /* extra credit-card calibration only if resolution passes */
        if (passAll) {
          html += `
        <hr style="margin:0 0 30px;">
        <div style="max-width:900px;margin:0 auto;text-align:left;">
          <p style="font-size:20px;font-weight:700;">Physical-size calibration</p>
          <p>Drag until the <span style="font-weight:700;">grey card</span>
             matches a real credit&nbsp;card.</p>
        </div>

        <div style="display:flex;justify-content:center;">
          <div id="card-block"
               style="width:500px;height:315px;background:#dedede;
                      border:1px solid #999;border-radius:8px;"></div>
        </div>

        <input id="card-slider" type="range" min="80" max="700" value="120"
               style="width:90%;display:block;margin:30px auto 0;">

        <div style="text-align:center;margin-top:32px;">
          <button id="card-check"
                  style="padding:10px 34px;font-size:18px;border:none;border-radius:4px;
                         background:#0d6efd;color:#fff;cursor:pointer;">
            Check size
          </button>
          <p id="card-msg" style="margin-top:12px;font-size:18px;font-weight:700;"></p>
        </div>`;
        }
        return html;
      },

      /* ------------------------------------------------------------------------ */
      on_load: () => {
        installZoomBlocker();
        /* re-eval pass/fail for logic here */
        const dpr = window.devicePixelRatio || 1,
          swCSS = screen.width,
          shCSS = screen.height,
          swPhy = Math.round(swCSS * dpr),
          shPhy = Math.round(shCSS * dpr),

          ok1080 = (swPhy >= 1880 && swPhy <= 1960) &&
            (shPhy >= 1040 && shPhy <= 1120),
          okDPR = (dpr >= 1.20 && dpr <= 1.30),
          winOK = Math.abs(((swCSS * dpr) / innerWidth) - dpr) < 0.02,

          passAll = ok1080 && okDPR && winOK;

        const [reBtn, quitBtn, contBtn] =
          document.querySelectorAll('.jspsych-btn');

        quitBtn.onclick = () => showDisqualifyPage();

        /* ---------------- RESOLUTION FAIL ---------------- */
        if (!passAll) {
          contBtn.disabled = true;
          contBtn.style.opacity = '.4';

          if (recheckAttempts >= 2) {
            reBtn.disabled = true;
            reBtn.style.opacity = '.4';
          }
          return;
        }

        /* ---------------- RESOLUTION PASS ---------------- */
        reBtn.style.display = 'none';
        quitBtn.style.display = 'none';

        const ASPECT = 85.6 / 53.98,
          slide = document.getElementById('card-slider'),
          card = document.getElementById('card-block'),
          check = document.getElementById('card-check'),
          msg = document.getElementById('card-msg');

        slide.oninput = () => {
          card.style.width = slide.value + 'px';
          card.style.height = (slide.value / ASPECT) + 'px';
        };
        slide.oninput();

        contBtn.disabled = true;
        contBtn.style.opacity = '.4';

        check.onclick = () => {
          const card = document.getElementById('card-block');

          // Use the rendered content width (excludes borders). This matches what the user aligns.
          const cardPx = card.clientWidth;                   // CSS px
          const mmPerCssPx = 85.6 / cardPx;                 // 85.60 mm is ID-1 width

          // Use the fullscreen viewport in CSS px (more robust than screen.*).
          const cssDiagPx = Math.hypot(window.innerWidth, window.innerHeight);

          const diagIn = (cssDiagPx * mmPerCssPx) / 25.4;   // inches
          const ok = (diagIn >= 15.3 && diagIn <= 15.9);
          const clr = ok ? '#28a745' : '#d9534f';

          msg.textContent = (ok ? 'PASS – ' : 'FAIL – ') + diagIn.toFixed(1) + '″';
          msg.style.color = clr;

          contBtn.textContent = ok ? 'Continue' : 'Quit';
          contBtn.style.background = clr;
          contBtn.disabled = false;
          contBtn.style.opacity = '1';

          if (!ok) contBtn.onclick = () => showDisqualifyPage();

          slide.disabled = true;
          check.disabled = true;
          check.style.opacity = '.5';
        };
      },

      /* ------------------------------------------------------------------------ */
      /* ---------------- on-finish handler ---------------- */
      on_finish: data => {
        // always stop blocking zoom shortcuts
        removeZoomBlocker();

        /* --------------------------------------------------
         * 0  = participant clicked the first button
         *      (“Re-check”, by construction in choices[])
         * -------------------------------------------------- */
        if (data.response === 0) {
          recheckAttempts++;

          /* after the 2nd Re-check → treat as an outright fail
             (same outcome as pressing “Quit”) */
          if (recheckAttempts >= 2) {
            showDisqualifyPage();
            return;
          }
        }

        /* store which button they clicked (for your own logs) */
        data.clicked = data.response;
      }
    };

    /* ──────────────────────────────────────────────────────────────────────────────
     *  LOOP ALLOWING UP TO TWO “RE-CHECK” ATTEMPTS
     * ──────────────────────────────────────────────────────────────────────────── */
    const verificationLoop = {
      timeline: [verificationPage],
      loop_function: data => {
        const last = data.values().at(-1);
        return last.clicked === 0 && recheckAttempts < 2;   // 0 = “Re-check”
      }
    };
  </script>

  <!-- ================== 3) Browser-Zoom Verification ================= -->
  <script>
    function zoomPct() { const dpr = window.devicePixelRatio || 1; return (dpr / 1.25) * 100; }

    var zoomCheckTrial = {
      type: jsPsychHtmlButtonResponse,
      stimulus: function () {
        const pct = zoomPct(), ok = pct >= 95 && pct <= 105;
        return `
          <h2 style="text-align:center;margin-top:10px;">Browser&nbsp;Zoom&nbsp;Check</h2>
          <p style="text-align:center;font-size:22px;margin:20px 0;">
             Current&nbsp;zoom&nbsp;:&nbsp;<b>${pct.toFixed(1)}&nbsp;%</b>
             ${ok ? '<span style="color:#28a745;font-weight:bold;">PASS</span>' :
            '<span style="color:#dc3545;font-weight:bold;">FAIL</span>'}
          </p>
          <p style="max-width:800px;margin:0 auto;font-size:15px;text-align:left;">
             The experiment must run at <b>exactly 100&nbsp;% browser&nbsp;zoom</b>.
             ${ok ? 'Great—no change needed.' :
            'Press <kbd>Ctrl + 0</kbd> (Windows) or <kbd>⌘ 0</kbd> (Mac) or use the browser menu to reset the zoom, then click Re-check.'}
          </p>`;
      },
      choices: ['Re-check', 'Continue'],
      on_load: function () {
        const pct = zoomPct(), ok = pct >= 95 && pct <= 105, btns = document.querySelectorAll('.jspsych-btn');
        if (ok) {
          btns[0].style.display = 'none'; btns[1].style.display = 'none';
          setTimeout(() => jsPsych.finishTrial({ zoom: pct }), 400);
        }
        else { btns[1].disabled = true; btns[1].style.opacity = '.4'; }
      },
      on_finish: data => data.zoom = zoomPct()
    };

    var zoomCheckLoop = {
      timeline: [zoomCheckTrial],
      loop_function: function (data) {
        const last = data.values().at(-1); return (last.zoom < 95 || last.zoom > 105) && last.response === 0;
      }
    };
  </script>

  <!-- ================= 3) Live ZOOM-/RES-GUARD (auto-resume, hard pause) ================ -->
  <script>
    let guardStarted = false;

    function startZoomGuard() {
      if (guardStarted) return;
      guardStarted = true;

      /* ── helper: are both zoom & resolution within limits? ── */
      function ok() {
        const dpr = window.devicePixelRatio || 1;

        /* browser zoom   (≈100 % ±5 %) */
        const zoomPct = (dpr / 1.25) * 100;
        const zoomOK = zoomPct >= 95 && zoomPct <= 105;

        /* NEW resolution limits */
        const sw = Math.round(screen.width * dpr);
        const sh = Math.round(screen.height * dpr);
        const resOK = (sw >= 1880 && sw <= 1960) &&
          (sh >= 1040 && sh <= 1120) &&
          (dpr >= 1.20 && dpr <= 1.30);

        return zoomOK && resOK;
      }


      /* ── overlay (no buttons) ── */
      let overlay = null;
      function show() {
        if (overlay) return;
        overlay = document.createElement('div');
        overlay.id = 'zoom-overlay';
        overlay.innerHTML = `
        <div class="prompt-box">
          <h3>Display settings changed</h3>
          <p style="max-width:620px;margin:0 auto;line-height:1.55;">
            • Browser zoom must stay at <b>100&nbsp;%</b>.<br>
            The experiment is paused and will resume automatically once
            everything is back within limits.
          </p>
        </div>`;
        document.body.appendChild(overlay);
      }
      function hide() {
        if (overlay) { document.body.removeChild(overlay); overlay = null; }
      }

      /* ── watcher ── */
      let paused = false;
      function watch() {
        /* if user manually exited fullscreen, let the fullscreen-guard handle things */
        if (!document.fullscreenElement) return;

        if (!ok()) {
          if (!paused) {
            paused = true;
            window.demoPaused = true;     /*  ←  makes pauseAwareTimeout freeze  */
            jsPsych.pauseExperiment();    /*  ←  stops timeline  */
            show();
          }
        } else if (paused) {
          hide();
          paused = false;
          window.demoPaused = false;
          jsPsych.resumeExperiment();
        }
      }

      /* react to any size change and poll every 500 ms */
      window.addEventListener('resize', watch);
      window.addEventListener('orientationchange', watch);
      setInterval(watch, 500);
      watch();
    }
  </script>

  <!-- ---------- tiny trial that starts guard right after loop -------- -->
  <script>
    const zoomGuardStarter = {
      type: jsPsychCallFunction,
      func: () => startZoomGuard()
    };
  </script>

  <script>
    /*************** 4) Demo Instructions Page ***************/
    var demoPage = {
      type: jsPsychHtmlButtonResponse,
      stimulus: `
        <img src="logo/NTU Logo.png" alt="NTU Logo" class="university-logo" style="height:230px; width:auto;">
        <div style="text-align:center;">
          <h3 style="margin-bottom:5px;">DEMO: The shifted image will move <b>to the left</b></h3>
          <div style="display:flex; justify-content:center; align-items:center; margin-top:10px;">
            <div style="margin:5px; text-align:center;">
              <img src="image/00001_Cube_Center_100_Plain_N0px.png" alt="Reference Image" style="width:300px; height:auto;"><br>
              <span>Reference Image</span>
            </div>
            <div style="margin:5px; text-align:center;">
              <img src="image/00031_Cube_Center_100_Plain_L30px.png" alt="Shifted Image" style="width:300px; height:auto;"><br>
              <span>Shifted Image</span>
            </div>
          </div>
          <div style="margin-top:10px; text-align:left; max-width:1200px; margin-left:auto; margin-right:auto; font-size:14px; line-height:1.2;">
            <p>
              In this demo, the left image is a fixed reference, while the right image will update periodically.
              The shifted image refreshes every 3 seconds. Between updates, it and the YES button will be temporarily disabled,
              but the layout remains in place.
            </p>
            <p>
              Once you notice a change (shift) in the right image relative to the left image, click "YES" to indicate detection.
              If you do not notice a change, it will keep updating until the final image.
            </p>
            <p>
              <strong>Note:</strong> Quitting the experiment at any point will erase all progress.
            </p>
            <p>
              <strong>Note:</strong> Please observe carefully as images could be repeating.
            </p>
            <p>
              <strong>Please be aware:</strong> we will use your demo performance to verify your understanding of the experiment.
              If the demo suggests lack of attention or understanding, it may affect your final compensation.
            </p>
          </div>
          <div style="margin-top:10px; font-size:14px;">
            <input type="checkbox" id="demo-confirm" name="demo-confirm">
            <label for="demo-confirm">I have read and understood the instructions.</label>
          </div>
        </div>
      `,
      choices: ['Start DEMO'],
      on_load: function () {
        var btn = document.querySelector(".jspsych-btn");
        btn.disabled = true;
        document.getElementById("demo-confirm").addEventListener("change", function () {
          btn.disabled = !this.checked;
        });
      }
    };
  </script>

  <script>
    /*************** 5) Demo Video Page ***************/
    var demoVideoTrial = {
      type: jsPsychHtmlButtonResponse,
      stimulus: `
        <h2 style="text-align:center; margin-top:10px;">Instructional Video</h2>
        <div style="max-width:1200px; margin:0 auto; text-align:center;">
          <video id="demo-video"
                class="no-progress"              
                controls
                controlsList="nodownload noremoteplayback"
                style="width:100%; height:auto; margin-top:10px;">
            <source src="data/Demo Video.mp4" type="video/mp4">
            Your browser does not support the video tag.
          </video>
        </div>
        <p style="margin-top:20px; text-align:center;">
          Please watch the entire video before proceed.
        </p>
      `,
      choices: ['Continue'],
      on_load: function () {
        const btn = document.querySelector('.jspsych-btn');
        btn.disabled = false;

        const video = document.getElementById('demo-video');
        let playStart = null;
        demoVideoWatchTime = 0; 

        // When video starts or resumes playing
        video.addEventListener('play', () => {
          playStart = Date.now();
        });

        // When video is paused or user seeks
        function accumulate() {
          if (playStart !== null) {
            demoVideoWatchTime += (Date.now() - playStart) / 1000;
            playStart = null;
          }
        }
        video.addEventListener('pause', accumulate);
        video.addEventListener('seeking', accumulate);

        // When video ends naturally
        video.addEventListener('ended', () => {
          accumulate();
          btn.disabled = false;
          console.log('Total watched (s):', demoVideoWatchTime);
        });

        // Also catch the Continue click if they skip before ending
        btn.addEventListener('click', () => {
          accumulate();
          console.log('Final watched (s):', demoVideoWatchTime);
        });
      }
    };
  </script>

  <script>
    /*************** 6) Dynamic Demo Trial ***************/
    var dynamicDemoTrial = {
      type: jsPsychHtmlButtonResponse,
      stimulus: '<div id="dynamic-demo-container"></div>',
      choices: ['YES'],
      response_ends_trial: false,
      on_load: function () {
        var btn = document.querySelector(".jspsych-btn");
        var yesBtnContainer = document.getElementById('yes-button-container');
        yesBtnContainer.appendChild(btn);
        yesBtnContainer.style.display = "none";
        btn.disabled = true;
        btn.style.opacity = "0.5";

        var container = document.getElementById("dynamic-demo-container");
        var numImages = 31;
        var demoImages = [];
        var imageFilenames = [];
        var loadingStartTime = Date.now();
        var trialFinished = false;

        imageFilenames.push("00001_Cube_Center_100_Plain_N0px.png");
        for (var j = 2; j <= numImages; j++) {
          var shift = j - 1;
          var padded = (j < 10) ? "0000" + j : "000" + j;
          var filename = padded + "_Cube_Center_100_Plain_L" + shift + "px.png";
          imageFilenames.push(filename);
        }

        var loadingScreenTimeout = setTimeout(function () {
          container.innerHTML = `
            <div class="loading-container">
              <p>Loading experiment, please wait...</p>
              <div class="progress-bar-container">
                <div id="loading-bar" class="progress-bar"></div>
              </div>
            </div>
          `;
          var loadingBar = document.getElementById("loading-bar");
          var progress = 0;
          var interval = setInterval(function () {
            progress += 5;
            if (progress >= 100) {
              clearInterval(interval);
            } else {
              loadingBar.style.width = progress + "%";
            }
          }, 100);
        }, 100);

        function loadImage(src) {
          const key = src;
          if (imageCache[key]) return Promise.resolve(imageCache[key]);

          return new Promise((resolve, reject) => {
            const img = new Image();
            img.onload = () => { imageCache[key] = img; resolve(img); };
            img.onerror = () => reject(src);
            img.src = "image/" + encodeURIComponent(src);
          });
        }

        Promise.all(imageFilenames.map(loadImage)).then(function (images) {
          demoImages = images;
          var loadingDuration = Date.now() - loadingStartTime;
          var minDisplayTime = 1000;
          var remainingTime = minDisplayTime - loadingDuration;
          setTimeout(function () {
            clearTimeout(loadingScreenTimeout);
            startCountdown();
          }, Math.max(0, remainingTime));
        }).catch(function (err) {
          container.innerHTML = "<p>Error loading image: " + err + "</p>";
        });

        var currentIndex = 0;
        function nextImage() {
          if (trialFinished) return;
          if (currentIndex >= demoImages.length - 1) {
            finishTrial();
            return;
          }
          btn.disabled = true;
          btn.style.opacity = "0.5";
          var shiftImg = document.getElementById("shift-image");
          if (!shiftImg) return;
          shiftImg.style.visibility = "hidden";

          pauseAwareTimeout(function () {
            currentIndex++;
            shiftImg.src = demoImages[currentIndex].src;
            shiftImg.style.visibility = "visible";
            btn.disabled = false;
            btn.style.opacity = "1";
            pauseAwareTimeout(nextImage, 2000);
          }, 500);
        }

        function startCountdown() {
          btn.style.display = "none";
          container.innerHTML = `
            <div id="demo-header" style="text-align:center; margin-top:10px;">
              <h3 style="margin:0 0 10px 0;">
                Saliency object is moving <span style="font-size:1.5em; text-decoration:underline;">LEFT</span>
              </h3>
              <h3 id="countdown" style="font-size:72px; font-weight:bold; margin:100px;">3</h3>
            </div>
          `;
          var count = 3;
          function countdownTick() {
            if (demoPaused) {
              setTimeout(countdownTick, 100);
              return;
            }
            count--;
            var cd = document.getElementById("countdown");
            if (!cd) return;
            cd.innerHTML = count;
            if (count <= 0) {
              startDemo();
            } else {
              setTimeout(countdownTick, 1000);
            }
          }
          setTimeout(countdownTick, 1000);
        }

        function startDemo() {
          container.innerHTML = `
            <div id="demo-header" style="text-align:center; margin-top:10px;">
              <h3 style="margin:0 0 10px 0;">
                Saliency object is moving <span style="font-size:1.5em; text-decoration:underline;">LEFT</span>
              </h3>
            </div>
            <div id="demo-content" style="display:flex; justify-content:center; align-items:center;">
              <div style="margin:5px; text-align:center;">
                <img id="ref-image" src="${demoImages[0].src}" class="demo-image">
                <br><span class="caption">Reference Image</span>
              </div>
              <div style="margin:5px; text-align:center;">
                <img id="shift-image" src="${demoImages[currentIndex].src}" class="demo-image" style="visibility:visible;">
                <br><span class="caption">Shifted Image</span>
              </div>
            </div>
          `;
          document.getElementById('demo-content').classList.add('fullbleed');
          edgeLayout('ref-image', 'shift-image', 'demo-content', 0.9);
          document.getElementById("yes-button-container").style.display = "block";
          btn.style.display = "inline-block";
          btn.disabled = false;
          btn.style.opacity = "1";
          pauseAwareTimeout(nextImage, 2000);
        }

        /* -------------- MODIFIED CLICK HANDLER -------------- */
        btn.addEventListener("click", function () {
          if (trialFinished) return;
          trialFinished = true;

          var shiftImg = document.getElementById("shift-image");
          if (shiftImg) {
            var parsed = parseShiftFromFilename(shiftImg.src);
            window.demoPixelShift = parsed.shift;
            yesClickEvents.push({
              phase: "demo",
              direction: parsed.direction,
              shift: parsed.shift,
              filename: shiftImg.src
            });
          }
          finishTrial();
        });
        /* ---------------------------------------------------- */
        function finishTrial() {
          var btn = document.querySelector(".jspsych-btn");
          if (btn && btn.parentNode) {
            btn.parentNode.removeChild(btn);
          }
          var trialData = { chosen_shift: currentIndex };
          jsPsych.finishTrial(trialData);
        }
      }
    };
  </script>

  <script>
    /*************** 7) Demo Completion Page ***************/
    var demoCompleteTrial = {
      type: jsPsychHtmlButtonResponse,
      stimulus: `
        <h2 style="text-align:center;">You have completed the demo</h2>
        <p style="max-width:800px; margin:0 auto; font-size:16px; text-align:left;">
          <strong>Rules Recap:</strong><br>
          1) The reference image is constant.<br>
          2) The shifted image updates every 3 seconds.<br>
          3) When you notice a change, click the YES button.<br>
          4) Quitting midway disqualifies your progress.<br>
        </p>
        <p style="text-align:center; margin-top:20px;">
          Choose an option below:
        </p>
      `,
      choices: ['Redo DEMO', 'START ACTUAL EXPERIMENT'],
      on_finish: function () { /* Loop handled in timeline */ }
    };
  </script>

  <script>
    /*************** 8) Experiment Instructions Page ***************/
    var experimentInstructions = {
      type: jsPsychHtmlButtonResponse,
      stimulus: function () {
        window.selectedObject = getRandomElement(objectNames);
        window.selectedGroupKey = getRandomElement(Object.keys(groups));
        var props = groups[window.selectedGroupKey];
        var setsCount = props.length;
        return `
          <div style="text-align:center;">
            <h2>Actual Experiment:</h2>
            <p>The experiment will now run for a series of keys based on one randomly selected object and group.</p>
            <p>
              You have been assigned to <strong>${window.selectedGroupKey}</strong>.<br>
              You will perform <strong>${setsCount * 4 * SCALES.length} sets</strong> (each property contributes 4 directions) of experiments.
            </p>
            <p style="color:red; font-weight:bold;">
              WARNING: Refreshing the page will cause all progress to be lost.
            </p>
            <p>
              In each set, the same salient object will be used. The object will shift in 4 directions – Left, Right, Up, and Down.
              After each directional shift, please press <strong>YES</strong> once you observe a difference.
            </p>
            <p>
              Please take every part of the experiment seriously. Providing invalid or inattentive responses
              may affect your final payment.
            </p>
            <p>Once ready, please press START.</p>
          </div>
        `;
      },
      choices: ['START']
    };
  </script>

  <script>
    /*************** 9) Multi-Key Actual Experiment Trial with BATCHED PREFETCH ***************/
    var multiKeyExperimentTrial = {
      type: jsPsychHtmlButtonResponse,
      stimulus: '<div id="actual-exp-container"></div>',
      choices: ['YES'],
      response_ends_trial: false,

      on_load: function () {

        /* ========== create / place the YES button ========== */
        clearYesClickEvents();
        let btn = document.querySelector('.jspsych-btn');
        if (!btn) {
          btn = document.createElement('button');
          btn.className = 'jspsych-btn';
          btn.textContent = 'YES';
        }
        const yesWrap = document.getElementById('yes-button-container');
        yesWrap.appendChild(btn);
        yesWrap.style.display = 'none';
        btn.style.display = 'none';

        /* ========== progress ring ========== */
        const properties = groups[window.selectedGroupKey];
        const totalSets = properties.length * 4 * SCALES.length;
        document.getElementById('progress-circle').style.display = 'block';
        window.completedSets = 0;
        window.updateProgressCircle = () => {
          const angle = ((totalSets - window.completedSets) / totalSets) * 360;
          document.getElementById('progress-circle').style.background =
            `conic-gradient(#4CAF50 0deg, #4CAF50 ${angle}deg, #ccc ${angle}deg, #ccc 360deg)`;
        };
        window.updateProgressCircle();

        const experimentResults = [];

        /* ──────────────────────────────────────────────
           Helpers for the size-transition screen
        ────────────────────────────────────────────── */
        function hideYesBtn() { btn.style.display = 'none'; }

        function showScaleTransition(scaleFactor, afterCb) {
          const pct = Math.round(scaleFactor * 100);
          const c = document.getElementById('actual-exp-container');
          c.innerHTML = `
        <div style="display:flex;flex-direction:column;align-items:center;
                    justify-content:center;height:80vh;font-family:Arial,Helvetica,sans-serif;">
          <h2 style="margin-bottom:16px;">Starting next set(different stimuli size)</h2>
          <p style="font-size:20px;">This set has no link to prior set</b></p>
        </div>`;
          document.getElementById('yes-button-container').style.display = 'none';
          pauseAwareTimeout(afterCb, 3000);
        }

        /* ──────────────────────────────────────────────
           TOP-LEVEL loop over the three scale factors
        ────────────────────────────────────────────── */
        function runExperimentForScale(scaleIdx) {

          /* --- finished all three sizes? --- */
          if (scaleIdx >= SCALES.length) {
            hideYesBtn();
            jsPsych.finishTrial({
              object: window.selectedObject,
              group: window.selectedGroupKey,
              results: experimentResults,
              ...window.stimSizesByScale
            });
            return;
          }

          /* run the body either immediately (first set) or after the 3-s screen */
          const startBody = () => runScaleBody(SCALES[scaleIdx]);
          (scaleIdx === 0) ? startBody() : showScaleTransition(SCALES[scaleIdx], startBody);

          /* ===============================================
             Inner body: all properties for *one* scale
          =============================================== */
          function runScaleBody(currentScale) {

            function runExperimentForProperty(propIdx) {
              if (propIdx >= properties.length) {
                return runExperimentForScale(scaleIdx + 1);
              }

              const property = properties[propIdx];
              const searchKey = `${window.selectedObject}_${property}`;

              runDirectionalExperiment(
                searchKey,
                property,
                currentScale,
                (phaseResults, filenames) => {

                  const sizeKeyW = `stim_${currentScale}_width`;
                  if (!window.stimSizesByScale[sizeKeyW]) {
                    const firstURL = 'https://lasvientuexperimentdata.s3.ap-southeast-1.amazonaws.com/Rendered+Images/' +
                      encodeURIComponent(filenames[0][0]);
                    loadImage(firstURL).then(img => {
                      window.stimSizesByScale[sizeKeyW] =
                        Math.round(img.naturalWidth * currentScale);
                      window.stimSizesByScale[`stim_${currentScale}_height`] =
                        Math.round(img.naturalHeight * currentScale);
                    });
                  }
                  experimentResults.push({
                    scale: currentScale,
                    property: `${property}_${currentScale}`,
                    phaseResults,
                    filenames
                  });

                  runExperimentForProperty(propIdx + 1);
                }
              ); /* runDirectionalExperiment */
            }
            runExperimentForProperty(0);
          } /* runScaleBody */
        } /* runExperimentForScale */

        /* ─── START the whole experiment ─── */
        runExperimentForScale(0);
      } /* on_load */
    };

    /******************************************************************
     * 3) Directional experiment (one property, four directions)
     *    – unchanged logic, but now receives `scaleFactor`
     *****************************************************************/
    function runDirectionalExperiment(searchKey, propertyName, scaleFactor, callback) {
      const btn = document.querySelector('#yes-button-container .jspsych-btn')
        || document.querySelector('.jspsych-btn');
      const container = document.getElementById('actual-exp-container');

      /* --- loading screen --- */
      container.innerHTML = `
        <div class="loading-container">
          <p>Loading experiment, please wait...</p>
          <div class="progress-bar-container">
            <div id="exp-loading-bar" class="progress-bar"></div>
          </div>
        </div>`;
      document.getElementById('yes-button-container').style.display = 'none';
      let progress = 0;
      const loadingBar = document.getElementById('exp-loading-bar');
      const loadingInt = setInterval(() => {
        progress += 5;
        loadingBar.style.width = progress + '%';
        if (progress >= 100) clearInterval(loadingInt);
      }, 100);

      /* --- get file list --- */
      fetchImageFilenames(searchKey).then(fileNames => {
        if (fileNames.length < 401) {
          container.innerHTML = `<p>Need ≥ 401 images for “${searchKey}” but got ${fileNames.length}.</p>`;
          return callback({}, fileNames);
        }
        fileNames = fileNames.slice(0, 401);

        /* split into original + 4 dirs */
        const original = fileNames[0];
        const left = fileNames.slice(1, 101);
        const right = fileNames.slice(101, 201);
        const up = fileNames.slice(201, 301);
        const down = fileNames.slice(301, 401);

        const phases = [
          { label: 'LEFT', dir: 'L', filenames: [original, ...left] },
          { label: 'RIGHT', dir: 'R', filenames: [original, ...right] },
          { label: 'UP', dir: 'U', filenames: [original, ...up] },
          { label: 'DOWN', dir: 'D', filenames: [original, ...down] }
        ];

        const baseURL = 'https://lasvientuexperimentdata.s3.ap-southeast-1.amazonaws.com/Rendered+Images/';
        const INITIAL_CACHE = 5;
        const PREFETCH_BORDER = 2;
        const PREFETCH_CHUNK = 2;

        let phaseIdx = 0;
        let imgIdx = 0;
        let highestCached = 0;
        const phaseResults = {};

        /* utility: cache a list of indices for the current phase */
        const cacheIndices = idxArr => {
          const f = phases[phaseIdx].filenames;
          idxArr.forEach(i => loadImage(baseURL + encodeURIComponent(f[i])));
        };

        /* YES handler */
        const yesHandler = () => {
          if (btn.disabled) return;

          const phase = phases[phaseIdx];
          const imgEl = document.getElementById('exp-shift-image');
          const imgURL = imgEl.src;
          const parsed = parseShiftFromFilename(imgURL);

          const propScaled = `${propertyName}_${scaleFactor}`;

          yesClickEvents.push({
            phase: 'actual',
            group: window.selectedGroupKey,
            property: propScaled,
            direction: parsed.direction,
            shift: parsed.shift,
            filename: imgURL,
          });

          phaseResults[phase.label] = {
            imageIndex: imgIdx,
            filename: imgURL,
            pixelShift: parsed.shift,
            direction: parsed.direction,
            property: propScaled,
          };

          window.completedSets++;
          window.updateProgressCircle();
          nextPhase();
        };

        btn.addEventListener('click', yesHandler);

        /* ----- phase helper functions ----- */
        const startPhaseCountdown = () => {
          btn.style.display = 'none';
          const phase = phases[phaseIdx];
          container.innerHTML = `
            <div id="exp-header" style="text-align:center; margin-top:10px;">
              <h3>Saliency object will move
                <span style="font-size:1.5em; text-decoration:underline;">${phase.label}</span>
              </h3>
              <h3 id="exp-countdown" style="font-size:72px; font-weight:bold; margin:100px;">3</h3>
            </div>`;
          let c = 3;
          const tick = () => {
            if (demoPaused) return setTimeout(tick, 100);
            document.getElementById('exp-countdown').textContent = --c;
            c ? setTimeout(tick, 1000) : startPhase();
          };
          setTimeout(tick, 1000);
        };

        const startPhase = () => {
          imgIdx = 0;
          highestCached = Math.min(INITIAL_CACHE, phases[phaseIdx].filenames.length - 1);
          cacheIndices([...Array(highestCached + 1).keys()]);

          document.getElementById('yes-button-container').style.display = 'block';
          btn.style.display = 'inline-block';
          btn.disabled = false;
          btn.style.opacity = '1';
          showFrame();
        };

        const showFrame = () => {
          const phase = phases[phaseIdx];
          const fname = phase.filenames[imgIdx];

          container.innerHTML = `
            <div id="exp-header" style="text-align:center;margin-top:10px;">
              <h3>Saliency object will move
                <span style="font-size:1.5em;text-decoration:underline;">${phase.label}</span>
              </h3>
            </div>

            <div id="exp-content" style="display:flex;justify-content:center;align-items:center;width:100%;">
              <div style="text-align:center;">
                <img id="exp-ref-image"
                    src="${baseURL + encodeURIComponent(phase.filenames[0])}"
                    class="demo-image">
                <br><span class="caption">Reference Image</span>
              </div>
              <div style="text-align:center;">
                <img id="exp-shift-image"
                    src="${baseURL + encodeURIComponent(fname)}"
                    class="demo-image"
                    style="visibility:visible;">
                <br><span class="caption">Shifted Image</span>
              </div>
            </div>
          `;

          // Make the jsPsych wrapper fill width but avoid horizontal scroll
          const wrapEl = document.querySelector('.jspsych-content-wrapper');
          if (wrapEl) {
            wrapEl.style.maxWidth = '100%';
            wrapEl.style.width = '100%';
            wrapEl.style.overflowX = 'hidden';
            wrapEl.style.boxSizing = 'border-box';
          }

          // Full-bleed strictly for 0.9 only
          const expContentEl = document.getElementById('exp-content');
          if (expContentEl) {
            if (scaleFactor === 0.9) expContentEl.classList.add('fullbleed');
            else expContentEl.classList.remove('fullbleed');
          }

          // Store displayed CSS size for this scale (once)
          const wKey = `stim_${scaleFactor}_width`;
          if (!window.stimSizesByScale[wKey]) {
            requestAnimationFrame(() => {
              const rect = document.getElementById('exp-ref-image').getBoundingClientRect();
              window.stimSizesByScale[wKey] = Math.round(rect.width);
              window.stimSizesByScale[`stim_${scaleFactor}_height`] = Math.round(rect.height);
            });
          }

          // 0.9 = edges; 0.75 and 0.6 use the 0.9-measured gap,
          // but ONLY 0.75 gets an extra measurement-based nudge.
          if (scaleFactor === 0.9) {
            edgeLayout('exp-ref-image', 'exp-shift-image', 'exp-content', scaleFactor, { mode: 'edges' });
            if (typeof window.baseInterImageGapPx !== 'number') {
              measureBaseGapWhenReady();
            }
          } else if (scaleFactor === 0.75) {
            whenBaseGapKnown((gap) => {
              edgeLayout('exp-ref-image', 'exp-shift-image', 'exp-content', scaleFactor, {
                mode: 'gap',
                gapPx: gap
              });
              nudgeGapToTarget('exp-content', gap);
            });
          } else if (scaleFactor === 0.6) {
            whenBaseGapKnown((gap) => {
              edgeLayout('exp-ref-image', 'exp-shift-image', 'exp-content', scaleFactor, {
                mode: 'gap',
                gapPx: gap
              });
              nudgeGapToTarget('exp-content', gap);
            });
          }

          // Enable YES and schedule next frame
          btn.disabled = false;
          btn.style.opacity = '1';
          pauseAwareTimeout(advanceFrame, 2000);
        };

        const advanceFrame = () => {
          const shiftImg = document.getElementById('exp-shift-image');
          if (!shiftImg || phaseIdx >= phases.length) return;
          btn.disabled = true;
          btn.style.opacity = '0.5';
          const phase = phases[phaseIdx];

          if (imgIdx < phase.filenames.length - 1) {
            const shiftImg = document.getElementById('exp-shift-image');
            shiftImg.style.visibility = 'hidden';

            pauseAwareTimeout(() => {
              imgIdx++;

              if (imgIdx + PREFETCH_BORDER > highestCached &&
                highestCached < phase.filenames.length - 1) {
                const start = highestCached + 1;
                const end = Math.min(highestCached + PREFETCH_CHUNK, phase.filenames.length - 1);
                cacheIndices(Array.from({ length: end - start + 1 }, (_, k) => k + start));
                highestCached = end;
              }

              shiftImg.src = baseURL + encodeURIComponent(phase.filenames[imgIdx]);
              shiftImg.style.visibility = 'visible';
              btn.disabled = false;
              btn.style.opacity = '1';
              pauseAwareTimeout(advanceFrame, 2000);
            }, 1000);
          } else {
            nextPhase();
          }
        };

        const nextPhase = () => {
          btn.disabled = true;
          btn.style.opacity = '0.5';
          phaseIdx++;
          if (phaseIdx < phases.length) startPhaseCountdown();
          else {
            btn.removeEventListener('click', yesHandler);
            callback(phaseResults, phases.map(p => p.filenames));
          }
        };
        startPhaseCountdown();
      })
        .catch(err => {
          container.innerHTML = `<p>Error fetching filenames: ${err}</p>`;
        });
    } /* runDirectionalExperiment */
  /* on_load */;
  </script>

  <script>
    /*************** 10) Final "Submit Data" Page ***************/
    var finalSubmissionTrial = {
      type: jsPsychHtmlButtonResponse,
      stimulus: `
        <div style="text-align:center;">
          <h2>Submit Your Data</h2>
          <p>Please press the button below to submit your data.</p>
          <p style="color:red; font-weight:bold;">WARNING: Do not refresh the page during the experiment; refreshing will cause all progress to be lost.</p>
        </div>
      `,
      choices: ['Submit Data'],
      on_finish: function () {
        var jsPsychDataArray = jsPsych.data.get().values();
        var trialSummary = jsPsychDataArray.map(function (trial) {
          return {
            trialIndex: trial.trial_index,
            trialType: trial.trial_type,
            response: trial.response,
            rt: trial.rt,
            chosenShift: trial.chosen_shift !== undefined ? trial.chosen_shift : null
          };
        });

        /* ------------  INCLUDE DEMO PIXEL-SHIFT  ------------ */
        var finalPayload = {
          participantID: window.participantID,
          selectedObject: window.selectedObject || null,
          group: window.selectedGroupKey || null,
          yesClicks: yesClickEvents,
          trialSummary: trialSummary,
          demoVideoWatchTime: demoVideoWatchTime,
          demoPixelShift: window.demoPixelShift ?? null,
          ...stimSizesByScale
        };
        /* ---------------------------------------------------- */

        var AWS_ENDPOINT = "https://i7nc0ict3h.execute-api.ap-southeast-1.amazonaws.com/storedata";
        fetch(AWS_ENDPOINT, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(finalPayload)
        })
          .then(response => response.json())
          .then(result => {
            console.log("Data posted successfully:", result);
          })
          .catch(error => {
            console.error("Error posting data:", error);
          });
      }
    };
  </script>

  <script>
    /*************** 11) Final Survey Code Page ****************/
    var finalCodeTrial = {
      type: jsPsychHtmlButtonResponse,
      stimulus: function () {
        return `
          <div style="text-align:center;">
            <h2>Response submitted!</h2>
            <p>You may close this window now!</p>
            <p>Your unique survey code is: <strong>${window.participantID}</strong></p>
          </div>
        `;
      },
      choices: ['Finish'],

      on_finish: function () {
        requestAnimationFrame(() => {
          window.open('', '_self');
          window.close();
        });
      }
    };
  </script>


  <script>
    /*********************************************************
     * ASSEMBLE TIMELINE
     *********************************************************/
    var timeline = [];
    timeline.push(welcomePage);          /* 1  ─ Welcome              */
    timeline.push(verificationLoop);     /* 2  ─ Display verification */

    timeline.push(zoomCheckLoop);        /* 3  ─ Browser-zoom check   */
    timeline.push(zoomGuardStarter);     /* 4  ─ Live zoom / res guard */

    // DEMO Timeline with new video watch time tracking
    var demoTimeline = {
      timeline: [
        demoPage,
        demoVideoTrial,
        dynamicDemoTrial,
        demoCompleteTrial
      ],
      loop_function: function (data) {
        var last_trial = data.values()[data.values().length - 1];
        // If last trial button was 'Redo DEMO' (response == 0), repeat
        return last_trial.response === 0;
      }
    };
    timeline.push(demoTimeline);

    timeline.push(experimentInstructions);
    timeline.push(multiKeyExperimentTrial);
    timeline.push(finalSubmissionTrial);
    timeline.push(finalCodeTrial);

    jsPsych.run(timeline);
  </script>
</body>

</html>
